state:int	title:string	subtitle1:string	subtitle2:string	subtitle3:string	subtitle4:string	opacity:float	prevenabled:int	nextenabled:int	resetenabled:int
0						0	0	1	0
1	Motivation	Suppose we have a single server and a single client who wishes to send a request to the server.	Click on the client to send its request.			1	1	1	0
2	Motivation	What happens if the server crashes or becomes unresponsive?	"This service has a single point of failure; when the server fails, the service can no longer process"	client requests. How can we make our service withstand server failures?		1	1	1	0
3	Motivation	"To add a form of fault-tolerance, we replicate the service state across multiple servers."	"The client sends a request to all the replica servers, who in turn all update their state."	Click on the client to broadcast its request.		1	1	1	0
4	Motivation	"Even if one server crashes, its state is replicated across several other servers. As long as one"	"replica stays alive, the client request can be processed."			1	1	1	0
5	Motivation	"What happens if there are multiple clients, all simulatenously sending requests to the servers?"	"The replicas must all process the same client request, or they would become desynchronized."	Click on either client to broadcast its request. Try to desynchronize the replicas by clicking on 	the two clients in rapid succession!	1	1	1	0
6	Motivation	We could have a single primary server that chooses which client request to process and	broadcasts it to the replicas.	"Click on either client to send its request. Once the primary has chosen a request, click on it to"	broadcast it to the replicas.	1	1	1	0
7	Motivation	"Again, what happens if the primary server crashes? Just like before, our servers have a single"	point of failure; one machine failing means we can no longer serve clients.			1	1	1	0
8	Motivation	"To remove any single point of failure and still have fault-tolerance, we can make the replicas"	decide amongst themselves which client request to process. This problem is called distributed	"consensus, since the replicas make a collective decision without a centralized coordinator."		1	1	1	0
9	Paxos	"Paxos is the typical algorithm for performing distributed consensus. In the algorithm, servers"	"vote on client requests, and process one request once a majority has voted on it."			1	1	1	0
10	Paxos Clusters	"In the Paxos algorithm, a server can take on one of three roles in the consensus process."				1	1	1	0
11	Paxos Clusters	"The first role is the proposer, who receives client messages and attempts to get them voted on"	by proposing them.			1	1	1	0
12	Paxos Clusters	"The second role is the acceptor, who receives proposals for client requests and votes on them."				1	1	1	0
13	Paxos Clusters	"The third role is the learner, who learns when a proposed request has elected by the cluster."	"Learners process elected requests, acting as replicas for the server state."			1	1	1	0
14	Paxos Walkthrough	caption for state 14				1	1	1	0
15	Paxos Walkthrough	caption for state 15				1	1	1	0
16	Paxos Walkthrough	caption for state 16				1	1	1	0
17	Paxos Walkthrough	caption for state 17				1	1	1	0
18	Paxos Walkthrough	caption for state 18				1	1	1	0
19	Paxos Walkthrough	caption for state 19				1	1	1	0
20	Paxos Walkthrough	caption for state 20				1	1	1	0
21	Paxos Demo	caption for state 21				1	1	0	1
